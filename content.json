{"pages":[{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java/index.html"},{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java/java-02.html"},{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java/java-01.html"},{"title":"about","text":"搭建自己的博客，为自己的学习记录下美好的篇章。也给广大的学习爱好者一个参考，讨论的环境，希望大家多多支持。 (╹▽╹) 生活无难事，只怕有心人","link":"/about/index.html"},{"title":"相册","text":"缩略图相册","link":"/photo/index.html"}],"posts":[{"title":"Activiti框架常用-流程节点撤回","text":"在工作中会用到Activiti框架来走流程，会有一些信息填写异常等状况，我们可以将节点撤回到指定节点。 创建测试类，引入测试用到的配置文件123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 撤回到指定节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Test public void test(){ rollBackToAssignWoekFlow(\"5001\",\"usertask2\"); } /** * 撤回 * @param processInstanceId * @param destTaskkey */ public void rollBackToAssignWoekFlow(String processInstanceId,String destTaskkey){ // 取得当前任务.当前任务节点 destTaskkey =\"usertask2\"; // HistoricTaskInstance currTask = historyService.createHistoricTaskInstanceQuery().taskId(taskId).singleResult(); Map&lt;String, Object&gt; variables; ExecutionEntity entity = (ExecutionEntity) runtimeService.createExecutionQuery().executionId(processInstanceId).singleResult(); ProcessDefinitionEntity definition = (ProcessDefinitionEntity)((RepositoryServiceImpl)repositoryService) .getDeployedProcessDefinition(entity.getProcessDefinitionId()); variables = entity.getProcessVariables(); //当前活动环节 ActivityImpl currActivityImpl = definition.findActivity(entity.getActivityId()); //目标活动节点 ActivityImpl nextActivityImpl = ((ProcessDefinitionImpl) definition).findActivity(destTaskkey); if(currActivityImpl !=null){ //所有的出口集合 List&lt;PvmTransition&gt; pvmTransitions = currActivityImpl.getOutgoingTransitions(); List&lt;PvmTransition&gt; oriPvmTransitions = new ArrayList&lt;PvmTransition&gt;(); for(PvmTransition transition : pvmTransitions){ oriPvmTransitions.add(transition); } //清除所有出口 pvmTransitions.clear(); //建立新的出口 List&lt;TransitionImpl&gt; transitionImpls = new ArrayList&lt;TransitionImpl&gt;(); TransitionImpl tImpl = currActivityImpl.createOutgoingTransition(); tImpl.setDestination(nextActivityImpl); transitionImpls.add(tImpl); List&lt;Task&gt; list = taskService.createTaskQuery().processInstanceId(entity.getProcessInstanceId()) .taskDefinitionKey(entity.getActivityId()).list(); for(Task task:list){ taskService.complete(task.getId(), variables); historyService.deleteHistoricTaskInstance(task.getId()); } for(TransitionImpl transitionImpl:transitionImpls){ currActivityImpl.getOutgoingTransitions().remove(transitionImpl); } for(PvmTransition pvmTransition:oriPvmTransitions){ pvmTransitions.add(pvmTransition); } } }","link":"/2019/10/14/Activiti框架——流程撤回/"},{"title":"Docker入门1 —— 搭建Docker","text":"在服务器方面，为了更加高效的利用空间，提供效率，Docker容易已经成为了大型项目容器的不二之选，接下来就一起学习吧 一、安装VMware Workstation Pro使用这个软件，可以直接在电脑中运行虚拟机 里边还有Xshell、Xftp工具，可以方便的操作虚拟机 链接：https://pan.baidu.com/s/1x5bhEh5pUajfA7fA6iMvNg提取码：gxju 直接安装即可 二、在VMware中安装centos7centos7镜像下载地址 http://isoredirect.centos.org/centos/7/isos/x86_64 不会的可以参考这个链接 https://blog.csdn.net/babyxue/article/details/80970526 三、配置虚拟机IP地址参考：https://blog.csdn.net/weixin_38214171/article/details/85330179 最后如下图，显示连接数据配置成功 1ping www.baidu.com 四、安装Docker在linux和windows中安装Docker很容易出错，所以我们直接使用centos7+yml的方式安装 运行下面的 yum 命令： 1yum install docker 安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动： 12service docker startchkconfig docker on 查看是否安装成功 1docker version 如果显示版本信息等，说明安装成功 五、修改国内镜像地址因为官网镜像地址速度比较慢，所以我们配置国内的镜像地址提高效率。Docker 中国官方镜像加速可通过registry.docker-cn.com访问。该镜像库只包含流行的公有镜像，私有镜像仍需要从美国镜像库中拉取。 把daemon.json修改为下边内容： 12345678vi /etc/docker/daemon.json#添加后{ &quot;registry-mirrors&quot;: [&quot;https://alzgoonw.mirror.aliyuncs.com&quot;] }#配置完成后 按ESC wq: 保存退出#重启dockerservice docker restart 六、验证是否能获取到镜像内的文件12#本地没有，会自动从环境下下载启动docker run hello-world 显示如下，说明配置成功 七、Docker常用命令可以直接输入docker，来查看所有命令 下面是一些常用的命令 1234567891011121314151617181920212223242526272829303132333435363738394041#查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下:docker images#拉取docker镜像docker pull image_name#删除镜像docker rmi docker.io/tomcat:7.0.77-jre7 或者 docker rmi b39c68b7af30#查看当前有哪些容器正在运行docker ps#查看所有容器docker ps -a#启动、停止、重启容器命令：docker start container_name/container_iddocker stop container_name/container_iddocker restart container_name/container_id#后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：docker attach container_name/container_id#删除容器的命令：docker rm container_name/container_iddocker rm container_id#删除所有停止的容器：docker rm $(docker ps -a -q)#查看当前系统Docker信息docker info#从Docker hub上下载某个镜像:docker pull centos:latest#查找Docker Hub上的nginx镜像docker search nginx#将Centos这个仓库下面的所有镜像下载到本地repository。docker pull centos","link":"/2019/10/10/Docker入门1--搭建Docker/"},{"title":"Spring-Cloud 初识","text":"微服务现在作为一线城市的开发工作人员而言，已经是必备技能了，我也不约而同的进入了微服的学习阶段，接下来的都是我自己在搭建微服务的记录，算是自己的笔记，方便后续翻看。 一、微服务介绍","link":"/2019/09/21/Spring-Cloud 初识/"},{"title":"Docker入门2 —— 搭建自己的Dockerfile","text":"下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 一、注册docker账号进入官网 cloud.docker.com 去注册一个docker账号 二、构建镜像这个额镜像是本地放置缓存的，上传用的 1234#默认位置docker build . #指定位置 -f指定该文件的位置docker build -f /user/local/docker/koa-demos . 最后提示，表示构建成功 1#Successfully built aa495654514e 构建成功 三、以NGINX为例，如何构建镜像、启动 找到一个空白目录，创建一个文本目录 Dockerfile 1234567891011#执行方法如下mkdir mynginxcd mynginxvi Dockerfile#Dockerfile内容 ：FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.htmlvi Dockerfile#保存 退出 这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。 在 Dockerfile 文件所在目录执行： 1docker build -t nginx:v1 .","link":"/2019/10/11/Docker入门2/"},{"title":"Docker实战1 —— IDEA插件连接Docker部署（Dockerfile）","text":"Idea作为大家常用的开发软件，他的强大的插件库让我们的开发变的更加方便，接下来我们就来用docker连接的插件，让我们的docker部署变得更加容易吧。 一、开放docker和防火墙的端口参考： https://www.cnblogs.com/hsz-csy/p/9488469.html 1vi /usr/lib/systemd/system/docker.service 在ExecStart=/usr/bin/dockerd-current 后面加上 (效果如图) -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 12#修改防火墙开方端口：vi /etc/sysconfig/iptables 12#之后重启防火墙即可service iptables restart 二、下载插件 像这样，安装后重启软件 重启之后 同样进入设置中，选择Docker配置 如图： 三、IDEA的Docker插件实战参考： https://xinchen.blog.csdn.net/article/details/100051325#commentsedit 创建一个SpringBoot项目 pom.xml 的内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.bolingcavalry&lt;/groupId&gt; &lt;artifactId&gt;dockerplugindemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dockerplugindemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 把启动类 同时设置为Controller使用 1234567891011121314151617/** * 用启动类同时作为Controller，增加一个web响应接口： */@SpringBootApplication@RestControllerpublic class DockerApplication { public static void main(String[] args) { SpringApplication.run(DockerApplication.class, args); } @RequestMapping(&quot;/test&quot;) public String test(){ return &quot;1. Hello world ! &quot; + new SimpleDateFormat(&quot; [yyyy-mm-dd HH:mm:ss]&quot;).format(new Date()); }} 在项目的根目录中(pom.xml文件所在目录下)，创建名字为 *Dockerfile * 的文件，内容如下 123456789101112131415161718192021222324# Docker image for springboot application# VERSION 0.0.1# Author: bolingcavalry### 基础镜像，使用alpine操作系统，openjkd使用8u201FROM openjdk:8u201-jdk-alpine3.9#作者MAINTAINER BolingCavalry &lt;zq2599@gmail.com&gt;#系统编码ENV LANG=C.UTF-8 LC_ALL=C.UTF-8#声明一个挂载点，容器内此路径会对应宿主机的某个文件夹VOLUME /tmp#应用构建成功后的jar文件被复制到镜像内，名字也改成了app.jarADD target/dockerplugindemo-0.0.1-SNAPSHOT.jar app.jar#启动容器时的进程ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]#暴露8080端口EXPOSE 8080 创建Dockerfile配置 最后在下边选择maven 1clean package -U -DskipTests 在这件Command line 输入 12#表示每次在构建镜像之前，都会将当前工程清理掉并且重新编译构建：clean package -U -DskipTests 完成后就可以启动了 点击绿色三角，启动项目 没有报错，可以直接访问地址 （ http://192.168.19.128:18080/test ）换成自己的ip地址 访问到说明成功了，如果有修改再去运行就好了","link":"/2019/10/12/Docker实战1/"},{"title":"搭建一个自己的博客","text":"搭建博客的方法众多，我选择的搭建的平台是放在了 github pages 上边(这个功能是为大家免费提供的，不过只能放静态页面，不过作为个人博客使用已经足够了) 接下来就开始真正的搭建之旅吧。 一、安装所需插件在安装HEXO之前还需要安装另外两个软件(我用的是PC端版本) 1. git2. Node.js （自带npm）安装好之后检测是否安装成功 win + R cmd 进入 输入代码检查是否安装完成 123git --versionnode -vnpm -v 如果都显示出版本号，那么恭喜安装完成！ 二、创建路径在自己的电脑中找到一个路径，创建一个文件夹，我的如下：G:\\crc-bk 三、进入git编辑模式进入自己的文件夹里边后鼠标右键，点击 Git Bash Here 按钮 四、安装HEXO1. 下载hexo网上有很多的教程都是（第一个安装HEXO，第二个将HEXO部署到github pages上去），但是实际操作的时候发现，等好久没反应。原来这几个下载的服务器都在国外，所以没有网络下载。 如果有翻墙的朋友们可以直接翻墙下载。 12npm install hexo-cli -g hexo init 如果没有的，也不要担心，已经有人搭建了国内的镜像给我们使用。 12npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm install -g hexo-cli 2. 初始化hexo12hexo initcnpm install 3. 本地启动hexo g –这是生成页面文件,必须先生成才能启动 hexo s –启动服务器 12hexo ghexo s 启动成功之后就可以在本地访问了 本地访问路径 localhost:4000 如果访问看到该页面，那么恭喜本地启动成功！ 五、修改配置在看自己创建文件夹的路径中已经有了好多文件 编辑模式打开_confit.yml 找到url位置，配置如下 url：https://自己git id.github.io root：自己文件名字 六、上传到git12npm install hexo-deployer-git --savehexo g -d 显示 INFO Deploy done：git 表示上传成功 成功之后就可以访问自己的博客了 访问地址 https:// git id.github.io/文件名 如（ https://876745833.github.io/crc-bk/ ） 七、更新自己的博客同样的在git编辑中，输入以下命令后，在 G:\\crc-bk\\source_posts 路径下会多出.md文件 接下来按照 markdown 的标准写博客，之后上传到 git 即可 查看上传步骤 1hexo n &quot;文章标题&quot;","link":"/2019/09/15/搭建自己的博客/"},{"title":"Docker实战3 —— IDEA插件连接Docker（compose）","text":"Idea作为大家常用的开发软件，他的强大的插件库让我们的开发变的更加方便，接下来我们就来用docker连接的插件，让我们的docker部署变得更加容易吧。","link":"/2019/10/14/Docker实战3/"},{"title":"Activiti框架——查询历史任务","text":"在Activiti框架的使用中，当我们走完一套流程之后，怎么查询我们的已经完成的任务呢？下边的方法就来介绍怎么使用。 创建测试类，引入测试用到的配置文件123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 查询流程任务这里有两种查询，根据所需 选择自己适合的方式来处理 这里我们需要注意两个方法的区别 HistoricActivityInstance（所有流程，包含流程启动、结束等） HistoricTaskInstance（人物执行相关，只有流程处理的节点） 12345678910111213141516/**查询历史活动 * act_hi_actinst 表中查 * HistoricActivityInstance（所有流程）和 HistoricTaskInstance（人物执行相关） */@Testpublic void findHisActivitiList(){ String processInstanceId = \"5001\"; List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery() .processInstanceId(processInstanceId).orderByProcessInstanceId().asc() .list(); if(list != null &amp;&amp; list.size()&gt;0){ for(HistoricActivityInstance hai : list){ System.out.println(hai.getId()+\"\"+hai.getActivityName()); } }} 123456789101112131415161718/** * 查询历史任务 * act_hi_taskinst 表中查 */@Testpublic void findHisTaskList(){ String processInstanceId = \"5001\"; List&lt;HistoricTaskInstance&gt; list = processEngine.getHistoryService() .createHistoricTaskInstanceQuery() .processInstanceId(processInstanceId).orderByProcessInstanceId().asc() .list(); if(list!=null &amp;&amp; list.size()&gt;0){ System.out.println(\"ID 流程名字 流程Key\"); for(HistoricTaskInstance hti:list){ System.out.println(hti.getId()+\" \"+hti.getName()+\" \"+hti.getTaskDefinitionKey()); } }} 查询历史流程变量查询完成的流程中，查询审核意见等一些参数（根据实例ID查询）。 12345678910111213141516/** * 查询历史流程变量 * act_hi_varinst 表中查 */@Testpublic void findHisVariablesList(){ String processInstanceId = \"5006\"; List&lt;HistoricVariableInstance&gt; list = historyService.createHistoricVariableInstanceQuery() .processInstanceId(processInstanceId) .list(); if(list != null &amp;&amp; list.size()&gt;0){ for(HistoricVariableInstance hvi:list){ System.out.println(hvi.getId()+\" \"+hvi.getVariableName()+\" \"+hvi.getValue()); } }}","link":"/2019/10/14/Activiti框架——查询历史任务/"},{"title":"Activiti————框架搭建","text":"在项目中，经常会用到流程的技术，可是自己写又非常麻烦，所以就有Activiti框架，为我们提供了一套比较完善的流程技术，在以后的项目中也会经常用到的。大家一起来学习一下吧 本项目已经全部上传github，项目地址： https://github.com/876745833/activiti-demo/tree/master 介绍 Activiti是一个轻量级的工作流和业务流程管理（BPM）平台，面向业务人员，开发人员和系统管理员。它的核心是用于Java的超快速，坚固的BPMN 2流程引擎。它是开源的，并根据Apache许可进行分发。Activiti可以在任何Java应用程序，服务器，集群或云中运行。它与Spring完美集成，非常轻巧，基于简单的概念。官方git地址 简单的说，就是一套工作申请用到框架。比如请假申请，是要经过层层的审核过程，这个时候就可以选择使用这个框架了，他本身帮我们创建的26张数据表(新版本或许更多)，提供的一些方法让我们这些程序员的开发变的更加方便、快捷。 话不多说，下边就可以正式进入框架的学习吧。 下边是搭建框架，先做好准备工作 导入jar包在maven项目中导入，在这里我们用的是 5.x版本 的 Mysql 数据库 和 5.x版本的Activiti 12345678910111213141516171819202122232425262728&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;!--activiti--&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--用到Activiti的ID策略的时候需要加--&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;com.fasterxml.uuid&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;java-uuid-generator&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;3.1.3&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt; 添加XML配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt; &lt;!-- 配置对应数据库 --&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\"&gt; &lt;property name=\"jdbcDriver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/activiti?characterEncoding=utf8\"/&gt; &lt;property name=\"jdbcUsername\" value=\"root\"/&gt; &lt;property name=\"jdbcPassword\" value=\"root\"/&gt; &lt;!-- 设置 表创建规则 databaseSchemaUpdate: 设置流程引擎启动和关闭时如何处理数据库表。 false（默认）：检查数据库表的版本和依赖库的版本， 如果版本不匹配就抛出异常。 true: 构建流程引擎时，执行检查，如果需要就执行更新。 如果表不存在，就创建。 create-drop: 构建流程引擎时创建数据库表， 关闭流程引擎时删除这些表。 --&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\"/&gt; &lt;!-- 是否使用activiti自带用户：用视图替换activiti用户 --&gt; &lt;!--&lt;property name=\"dbIdentityUsed\" value=\"false\"&gt;&lt;/property&gt;--&gt; &lt;!-- 主键生成策略 UUID --&gt; &lt;!--&lt;property name=\"idGenerator\"&gt;--&gt; &lt;!--&lt;bean class=\"org.activiti.engine.impl.persistence.StrongUuidGenerator\" /&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!-- 自定义主键生成策略 --&gt; &lt;property name=\"idGenerator\"&gt;&lt;bean class=\"TaskIdGenerator\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 使用工厂创建流程引擎对象 --&gt; &lt;bean id=\"processEngine\" class=\"org.activiti.spring.ProcessEngineFactoryBean\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\"/&gt; &lt;/bean&gt; &lt;!-- 注入bean 方便直接调用 (可选) --&gt; &lt;bean id=\"repositoryService\" factory-bean=\"processEngine\" factory-method=\"getRepositoryService\" /&gt; &lt;bean id=\"runtimeService\" factory-bean=\"processEngine\" factory-method=\"getRuntimeService\" /&gt; &lt;bean id=\"formService\" factory-bean=\"processEngine\" factory-method=\"getFormService\" /&gt; &lt;bean id=\"identityService\" factory-bean=\"processEngine\" factory-method=\"getIdentityService\" /&gt; &lt;bean id=\"taskService\" factory-bean=\"processEngine\" factory-method=\"getTaskService\" /&gt; &lt;bean id=\"historyService\" factory-bean=\"processEngine\" factory-method=\"getHistoryService\" /&gt; &lt;bean id=\"managementService\" factory-bean=\"processEngine\" factory-method=\"getManagementService\" /&gt;&lt;/beans&gt; 在配置中创建流程图如下是写的一个Demo流程图，直接在resources中创建一个leave.xml配置文件写入。 之后更改配置文件的后缀名， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:activiti=\"http://activiti.org/bpmn\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\" xmlns:tns=\"http://www.activiti.org/test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" expressionLanguage=\"http://www.w3.org/1999/XPath\" id=\"m1570697036721\" name=\"\" targetNamespace=\"http://www.activiti.org/test\" typeLanguage=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;process id=\"groupTaskDelegate\" isClosed=\"false\" isExecutable=\"true\" name=\"groupTaskDelegateProcess\" processType=\"None\"&gt; &lt;startEvent id=\"startevent1\" name=\"Start\"/&gt; &lt;userTask activiti:candidateGroups=\"部门主管\" activiti:exclusive=\"true\" id=\"usertask1\" name=\"部门主管审批\"/&gt; &lt;sequenceFlow id=\"flow1\" sourceRef=\"startevent1\" targetRef=\"usertask1\"/&gt; &lt;userTask activiti:candidateGroups=\"部门经理\" activiti:exclusive=\"true\" id=\"usertask2\" name=\"部门经理审批\"/&gt; &lt;sequenceFlow id=\"flow2\" sourceRef=\"usertask1\" targetRef=\"usertask2\"/&gt; &lt;userTask activiti:candidateGroups=\"CTO\" activiti:exclusive=\"true\" id=\"usertask3\" name=\"技术总监审批\"/&gt; &lt;sequenceFlow id=\"flow3\" sourceRef=\"usertask2\" targetRef=\"usertask3\"/&gt; &lt;endEvent id=\"endevent1\" name=\"End\"/&gt; &lt;sequenceFlow id=\"flow4\" sourceRef=\"usertask3\" targetRef=\"endevent1\"/&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram documentation=\"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0\" id=\"Diagram-_1\" name=\"New Diagram\"&gt; &lt;bpmndi:BPMNPlane bpmnElement=\"groupTaskDelegate\"&gt; &lt;bpmndi:BPMNShape bpmnElement=\"startevent1\" id=\"Shape-startevent1\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"290.0\" y=\"100.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask1\" id=\"Shape-usertask1\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"255.0\" y=\"200.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask2\" id=\"Shape-usertask2\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"255.0\" y=\"310.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask3\" id=\"Shape-usertask3\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"257.0\" y=\"420.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"endevent1\" id=\"Shape-endevent1\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"292.0\" y=\"510.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow1\" id=\"BPMNEdge_flow1\" sourceElement=\"startevent1\" targetElement=\"usertask1\"&gt; &lt;omgdi:waypoint x=\"306.0\" y=\"132.0\"/&gt; &lt;omgdi:waypoint x=\"306.0\" y=\"200.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow2\" id=\"BPMNEdge_flow2\" sourceElement=\"usertask1\" targetElement=\"usertask2\"&gt; &lt;omgdi:waypoint x=\"307.5\" y=\"255.0\"/&gt; &lt;omgdi:waypoint x=\"307.5\" y=\"310.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow3\" id=\"BPMNEdge_flow3\" sourceElement=\"usertask2\" targetElement=\"usertask3\"&gt; &lt;omgdi:waypoint x=\"308.5\" y=\"365.0\"/&gt; &lt;omgdi:waypoint x=\"308.5\" y=\"420.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow4\" id=\"BPMNEdge_flow4\" sourceElement=\"usertask3\" targetElement=\"endevent1\"&gt; &lt;omgdi:waypoint x=\"308.0\" y=\"475.0\"/&gt; &lt;omgdi:waypoint x=\"308.0\" y=\"510.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; 安装插件（Idea版本） 安装之后，再打开bpmn文件 流程图 如下：","link":"/2019/10/13/Activiti框架——搭建/"},{"title":"Activiti框架——按角色分配走流程","text":"在Activiti框架搭建好之后，我们要怎么使用这个框架呢？很简单，官方为我们提供了7个接口，分别操控框架的对应内容，下面我们来一起学习，简单的走一套完整的流程吧。 一、创建测试类，引入测试用到的配置文件下边是官方为我们提供的7大接口，他们的作用如下 123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 二、部署流程123456789101112131415161718/** * 流程定义(流程图的设计)好以后,需要部署 * 流程部署涉及到的几个动作和表 * 流程部署表 act_re_deployment * 流程定义表 act_re_procdef * 流程资源表 act_ge_bytearray */@Testpublic void complateTask() { Deployment deploy = processEngine.getRepositoryService() .createDeployment() .name(\"Activiti角色配置流程\")//部署上去名字 .addClasspathResource(\"leave.bpmn\")//bpmn文件路径 .addClasspathResource(\"leave.png\")//流程图 选择可有可无 .deploy();//部署 System.out.println(\"流程实例Id---&gt;\" + deploy.getId()); System.out.println(\"流程实例Name---&gt;\" + deploy.getName());} 在部署流程执行之后，我们在数据库中就会发现，多了很多的表，其中查看 act_re_procdef 在表 三、创建用户、角色、以及他们的对应关系1234567891011121314151617181920212223242526272829/** * 创建 角色/分组 */@Testpublic void testProcessDeploy() { IdentityService identityService = processEngine.getIdentityService(); //创建用户 act_id_user表 identityService.saveUser(new UserEntity(\"张三\")); identityService.saveUser(new UserEntity(\"李四\")); identityService.saveUser(new UserEntity(\"王五\")); identityService.saveUser(new UserEntity(\"赵六\")); identityService.saveUser(new UserEntity(\"田七\")); identityService.saveUser(new UserEntity(\"胡八\")); //创建角色 act_id_group表 identityService.saveGroup(new GroupEntity(\"部门主管\")); identityService.saveGroup(new GroupEntity(\"部门经理\")); identityService.saveGroup(new GroupEntity(\"CTO\")); System.out.println(\"角色创建完成\"); //创建角色和用户的对应关系 act_id_membership表 identityService.createMembership(\"张三\", \"部门主管\"); identityService.createMembership(\"李四\", \"部门主管\"); identityService.createMembership(\"王五\", \"部门经理\"); identityService.createMembership(\"赵六\", \"部门经理\"); identityService.createMembership(\"田七\", \"CTO\"); identityService.createMembership(\"胡八\", \"CTO\"); System.out.println(\"角色关系分配完成\");} 四、启动流程流程的启动方法有几种，我们采用最安全稳定的一种。通过实例ID来启动，保证唯一性。 12345678910111213141516171819/** * 流程的启动(流程实例的产生) new Class-&gt;Object * 涉及到的表 : * act_ru_execution 流程实例表 * act_ru_task 会产生一条待执行的任务记录 * act_hi_taskinst 也会产生一条历史任务记录(注意:endtime is null) * 注意: 以流程定义的key启动的话,默认会进入版本最新的流程 */@Testpublic void testStartProcess() { //根据key和version查出对应版本的实例Id String InstanceId = findProcessDefinition(key, version); //流程定义的key启动的话,默认会进入版本最新的流程 ProcessInstance processInstance = processEngine.getRuntimeService() .startProcessInstanceById(InstanceId,key);//启动流程 ,生成一个流程实例 System.out.println(\"流程部署的ID:\" + processInstance.getDeploymentId()); System.out.println(\"流程定义的ID:\" + processInstance.getProcessDefinitionId()); System.out.println(\"流程实例的ID:\" + processInstance.getProcessInstanceId()); System.out.println(\"流程启动完毕\");} 五、根据角色查询Task节点12345678910111213141516171819202122232425 /** * 根据角色查询某组的任务 */ @Test public void testQueryMyGroupTask() { String assignee = \"李四\"; String processinstanceId = \"30021\"; List&lt;Task&gt; taskList = processEngine.getTaskService() //跟任务处理相关的服务类 .createTaskQuery() //创建一个任务查询 .taskCandidateUser(assignee) //加入查询条件// .processInstanceId(processinstanceId)//查询某个任务 .list(); //返回形式 if (taskList != null &amp;&amp; taskList.size() &gt; 0) { for (Task task : taskList) { System.out.println(\"流程定义ID:\" + task.getProcessDefinitionId()); System.out.println(\"流程实例ID:\" + task.getProcessInstanceId()); System.out.println(\"执行对象ID:\" + task.getExecutionId()); System.out.println(\"任务ID:\" + task.getId());//任务ID:130004 System.out.println(\"任务名称:\" + task.getName()); System.out.println(\"任务的创建时间:\" + task.getCreateTime()); } } } 六、节点通过——人工流程申请过来的时候，我们要让对应的角色来完成任务，保证流程继续走下去 在分组的情况下，有人要来处理任务的时候，我们要保证只有一个人正在处理，所以我们用拾取任务来保证工作的唯一性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * 任务拾取 * 我们设置的任务处理人员暂时都只是候选人 ,并不是实际处理人,必须经过任务拾取的过程来确定谁来处理任务 * 任务拾取的过程,就是给执行任务表指定assginee字段值的过程 */ @Test public void claimTask() { String taskId = \"2504\";//刚才启动的Task的Id String userId = \"张三\";//任务拾取的用户 taskService.claim(taskId, userId); //任务拾取以后, 可以回退给组 //processEngine.getTaskService().setAssignee(taskId, null); //任务拾取以后,可以转给别人去处理(别人可以是组成员也可以不是) //processEngine.getTaskService().claim(taskId, \"xiaoxi\"); } /** * 人工节点通过方法 * 流程处理过程：完成个人任务 * 处理流程的步骤:查询个人任务 完成个人任务 * 涉及到的表：act_ru_task */ @Test public void testCompleteMyTask() { String taskId = \"22504\"; Map&lt;String, Object&gt; mapVariables = new HashMap&lt;String, Object&gt;();// mapVariables.put(\"manageId01\", \"部门主管\");// mapVariables.put(\"mes01\", \"同意，好好干，年底发红包\"); mapVariables.put(\"manageId02\", \"部门经理\"); mapVariables.put(\"mes02\", \"同意，好好干，年底发奖金\");// mapVariables.put(\"manageId03\", \"部门CTO\");// mapVariables.put(\"mes03\", \"同意，好好干，年底发分红\"); //带审核意见 processEngine.getTaskService().complete(taskId, mapVariables); System.out.println(\"审批完成\"); //不带审核意见// String taskId = \"25002\";// processEngine.getTaskService().complete(taskId);// System.out.println(\"审批任务完成\"); } 七、通过节点——自动1234567891011121314151617181920212223242526272829303132333435/** * 自动审核通过节点 */@Testpublic void testCompleteMyTaskSelf(){ String processDefinId = findProcessDefinition(key, version); ProcessInstance instance = runtimeService.startProcessInstanceById(processDefinId,key);//启动流程 ,生成一个流程实例 System.out.println(\"流程定义的ID:\" + instance.getProcessDefinitionId()); System.out.println(\"流程实例的ID:\" + instance.getProcessInstanceId()); Task task = taskService.createTaskQuery().processInstanceId(instance.getProcessInstanceId()).active().singleResult(); while (task!=null){ System.out.println(\"============\"+task.getName()+\" 流程开始 ============\"); Map&lt;String, Object&gt; mapVariables = new HashMap&lt;String, Object&gt;(); if (\"usertask1\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId01\", \"部门主管\"); mapVariables.put(\"mes01\", \"同意，好好干，年底发红包\"); } if (\"usertask2\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId02\", \"部门经理\"); mapVariables.put(\"mes02\", \"同意，好好干，年底发奖金\"); } if (\"usertask3\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId03\", \"部门CTO\"); mapVariables.put(\"mes03\", \"同意，好好干，年底发分红\"); } System.out.println(\"============\"+task.getName()+\" 流程结束 ============\"); //带审核意见 processEngine.getTaskService().complete(task.getId(), mapVariables); //重新获取task task = taskService.createTaskQuery().processInstanceId(instance.getProcessInstanceId()).active().singleResult(); } System.out.println(\"审批完成\");}","link":"/2019/10/14/Activiti框架——按角色分配走流程/"},{"title":"Activiti框架常用-自定义角色方案","text":"在工作中会用到Activiti框架的时候，很多时候我们会根据自己已经有的用户角色表，来关联整个框架，这里也有一套比较完美的方案，用视图的方法，具体操作如下。 一、修改XML配置文件 我们需要修改配置文件，使框架不生成原本的用户角色表 12&lt;!-- 是否使用activiti自带用户：用视图替换activiti用户 --&gt;&lt;&lt;property name=&quot;dbIdentityUsed&quot; value=&quot;false&quot;&gt;&lt;/property&gt; 二、执行sql语句我们先创建自定义的用户、角色表，然后根据用户角色表的字段，生成与框架表对应的视图，这样就可以实现自定义的关系实现了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 创建表sqldrop table users;drop table roles;drop table userrole;CREATE TABLE act.users(id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,name varchar(30),age varchar(20),password varchar(30));CREATE TABLE act.roles(id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,roleName varchar(30));CREATE TABLE act.userrole(userId int(11),roleId int(11));-- 插入数据INSERT INTO act.users (id, name, age, password) VALUES (1, '张三', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (2, '李四', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (3, '王五', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (4, '赵六', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (5, '田七', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (6, '胡八', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (7, '管理员', '25', 'admin');INSERT INTO act.roles (id, roleName) VALUES (1, '部门主管');INSERT INTO act.roles (id, roleName) VALUES (2, '部门经理');INSERT INTO act.roles (id, roleName) VALUES (3, 'CTO');INSERT INTO act.roles (id, roleName) VALUES (4, '管理员');INSERT INTO act.userrole (userId, roleId) VALUES (1, 1);INSERT INTO act.userrole (userId, roleId) VALUES (2, 1);INSERT INTO act.userrole (userId, roleId) VALUES (3, 2);INSERT INTO act.userrole (userId, roleId) VALUES (4, 2);INSERT INTO act.userrole (userId, roleId) VALUES (5, 3);INSERT INTO act.userrole (userId, roleId) VALUES (6, 3);INSERT INTO act.userrole (userId, roleId) VALUES (7, 4);-- 创建的视图要保证数据类型一致，例如用户的ACT_ID_MEMBERSHIP表的两个字段都是字符型，一般系统中都是用NUMBER作为用-- 户、角色的主键类型，所以创建视图的时候要把数字类型转换为字符型。-- ACT_ID_USERCREATE OR REPLACE VIEW ACT_ID_USER_hhh(id_, rev_, first_, last_, email_, pwd_, picture_id_) as SELECT u.id,1,u.name,null,null,u.password,null FROM users u;-- ACT_ID_GROUPcreate or replace view act_id_group(id_, rev_, name_, type_) as select t.roleName , 1 as rev_,t.roleName ,'' as type_ from roles t;-- ACT_ID_MEMBERSHIPcreate or replace view act_id_membership(user_id_, group_id_) as select u.name,r.roleName fromusers u inner join userrole uron u.id=ur.userId inner join roles r on ur.roleId=r.id;-- select * from users u,roles r inner join userrole ur where u.id = ur.userId and r.id=ur.roleId;","link":"/2019/10/14/Activiti框架——自定义角色配置/"},{"title":"Docker实战2 —— IDEA插件连接Docker（image）","text":"Idea作为大家常用的开发软件，他的强大的插件库让我们的开发变的更加方便，接下来我们就来用docker连接的插件，让我们的docker部署变得更加容易吧。","link":"/2019/10/13/Docker实战2/"},{"title":"Activiti框架——id生成策略","text":"在使用Activiti框架的时候，我们的项目中经常会根据自己的情况，生成指定规则的id主键，那么如何来自定义主键生成策略呢？下边为大家提供了一个方法，仅供参考。 在自定义ID的方法中，有两种——UUID的方法生成和自定义方法。 修改配置文件在配置文件中加入，使得框架使用我们自定义的规则生成ID 如果需要使用UUID的，加入UUID的配置即可 如果用自定义策略，加上配置后，还需要重写IdGenerator接口 1234567 &lt;!-- 自定义主键生成策略 --&gt; &lt;property name=\"idGenerator\"&gt;&lt;bean class=\"TaskIdGenerator\"/&gt; &lt;/property&gt;&lt;!-- 主键生成策略 UUID --&gt; &lt;property name=\"idGenerator\"&gt; &lt;bean class=\"org.activiti.engine.impl.persistence.StrongUuidGenerator\"/&gt;- &lt;/property&gt; 写一个类来实现 IdGenerator 接口 通过重写IdGenerator接口来实现自定义ID的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.net.InetAddress;import java.net.UnknownHostException;import java.text.SimpleDateFormat;import java.util.Date;import org.activiti.engine.impl.cfg.IdGenerator;public class TaskIdGenerator implements IdGenerator { private static TaskIdGenerator tp=new TaskIdGenerator(); private static int number=0; private static String ip=\"\"; private TaskIdGenerator(){} public static TaskIdGenerator getInstance(){ if(tp==null){ tp=new TaskIdGenerator(); } return tp; } public String getNextId() { return getTrace(); } /** * 交易流水的生成 * data（交易流水）=1（服务器IP）+YYMMDD（日期）+111111(6为时间戳)+11111(生成数字) */ public synchronized String getTrace(){ String data=null; String IP = null; String str= null; number++; try { if(ip.equals(\"\")) { ip=InetAddress.getLocalHost().getHostAddress().split(\"[.]\")[3]; } IP=ip; } catch (UnknownHostException e) { e.printStackTrace(); } SimpleDateFormat sdf=new SimpleDateFormat(\"yyyyMMddHHmmss\"); String dateStr=sdf.format(new Date()); dateStr = dateStr.substring(2, dateStr.length()); str=\"00000\"+number; str = str.substring(str.length()-5); data=IP+dateStr+str; if(number&gt;99999){ number=0; } return data; } public static void main(String[] args) throws UnknownHostException { System.out.println(); } }","link":"/2019/10/14/Activiti框架——id生成策略/"},{"title":"Activiti框架——搭建页面管理war包","text":"在项目中，经常会用到流程的技术，可是自己写又非常麻烦，所以就有Activiti框架，为我们提供了一套比较完善的流程技术，在以后的项目中也会经常用到的。大家一起来学习一下吧 最后官方为我们提供了一个界面化管理的war包，让我们更加方便的使用框架。下面来一起看看怎么使用吧。 介绍Activiti框架官方为我们提供了官方管理页面，我们只需要去官网下载，放入tomcat等服务器下运行即可。 下边是一个5.x版本的activiti，官方好像已经找不到了。大家有需要用可以通过下方链接下载 链接：https://pan.baidu.com/s/1TI_Yx2zawFm7udg9WywoAg提取码：6pse 修改文件内的DB地址修改war包内 路径： activiti-webapp.war\\WEB-INF\\classes 的 db.properties 中的数据库地址，改为自己的。 放入tomcat启动把修改好的war包放到，tomcat的webapp路径下。 接下来进入tomcat的bin目录，win版本的，双击startup.bat ，启动成功，去页面访问即可。 访问地址： http://localhost:8080/activiti-webapp/ 看到这个页面后，恭喜启动成功了。 可以使用系统默认用户访问 1234账号 密码 角色kermit kermit admingonzo gonzo managerfozzie fozzie user 登录后看到这个页面，说明成功了","link":"/2019/10/14/Activiti框架——搭建页面管理war包/"}],"tags":[{"name":"Activiti工作流","slug":"Activiti工作流","link":"/tags/Activiti工作流/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/tags/SpringCloud/"},{"name":"分享","slug":"分享","link":"/tags/分享/"}],"categories":[{"name":"框架","slug":"框架","link":"/categories/框架/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"SrpingCloud","slug":"框架/SrpingCloud","link":"/categories/框架/SrpingCloud/"},{"name":"Activiti工作流","slug":"框架/Activiti工作流","link":"/categories/框架/Activiti工作流/"},{"name":"博客系列","slug":"博客系列","link":"/categories/博客系列/"},{"name":"Linux","slug":"Docker/Linux","link":"/categories/Docker/Linux/"},{"name":"IDEA","slug":"Docker/IDEA","link":"/categories/Docker/IDEA/"},{"name":"Centos7","slug":"Docker/Linux/Centos7","link":"/categories/Docker/Linux/Centos7/"}]}