{"pages":[{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java-show/java/index.html"},{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java-show/java/java-02.html"},{"title":"java","text":"java 主题页面内容 ———— 一个java程序员的生活 java是目前生活中最火热的开发语言","link":"/java-show/java/java-01.html"},{"title":"about","text":"搭建自己的博客，为自己的学习记录下美好的篇章。也给广大的学习爱好者一个参考，讨论的环境，希望大家多多支持。 (╹▽╹) 生活无难事，只怕有心人","link":"/java-show/about/index.html"},{"title":"相册","text":"缩略图相册","link":"/java-show/photo/index.html"}],"posts":[{"title":"Activiti框架常用-流程节点撤回","text":"在工作中会用到Activiti框架来走流程，会有一些信息填写异常等状况，我们可以将节点撤回到指定节点。 创建测试类，引入测试用到的配置文件123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 撤回到指定节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Test public void test(){ rollBackToAssignWoekFlow(\"5001\",\"usertask2\"); } /** * 撤回 * @param processInstanceId * @param destTaskkey */ public void rollBackToAssignWoekFlow(String processInstanceId,String destTaskkey){ // 取得当前任务.当前任务节点 destTaskkey =\"usertask2\"; // HistoricTaskInstance currTask = historyService.createHistoricTaskInstanceQuery().taskId(taskId).singleResult(); Map&lt;String, Object&gt; variables; ExecutionEntity entity = (ExecutionEntity) runtimeService.createExecutionQuery().executionId(processInstanceId).singleResult(); ProcessDefinitionEntity definition = (ProcessDefinitionEntity)((RepositoryServiceImpl)repositoryService) .getDeployedProcessDefinition(entity.getProcessDefinitionId()); variables = entity.getProcessVariables(); //当前活动环节 ActivityImpl currActivityImpl = definition.findActivity(entity.getActivityId()); //目标活动节点 ActivityImpl nextActivityImpl = ((ProcessDefinitionImpl) definition).findActivity(destTaskkey); if(currActivityImpl !=null){ //所有的出口集合 List&lt;PvmTransition&gt; pvmTransitions = currActivityImpl.getOutgoingTransitions(); List&lt;PvmTransition&gt; oriPvmTransitions = new ArrayList&lt;PvmTransition&gt;(); for(PvmTransition transition : pvmTransitions){ oriPvmTransitions.add(transition); } //清除所有出口 pvmTransitions.clear(); //建立新的出口 List&lt;TransitionImpl&gt; transitionImpls = new ArrayList&lt;TransitionImpl&gt;(); TransitionImpl tImpl = currActivityImpl.createOutgoingTransition(); tImpl.setDestination(nextActivityImpl); transitionImpls.add(tImpl); List&lt;Task&gt; list = taskService.createTaskQuery().processInstanceId(entity.getProcessInstanceId()) .taskDefinitionKey(entity.getActivityId()).list(); for(Task task:list){ taskService.complete(task.getId(), variables); historyService.deleteHistoricTaskInstance(task.getId()); } for(TransitionImpl transitionImpl:transitionImpls){ currActivityImpl.getOutgoingTransitions().remove(transitionImpl); } for(PvmTransition pvmTransition:oriPvmTransitions){ pvmTransitions.add(pvmTransition); } } }","link":"/java-show/2019/10/14/Activiti框架——流程撤回/"},{"title":"Docker入门1 —— 搭建Docker","text":"在服务器方面，为了更加高效的利用空间，提供效率，Docker容易已经成为了大型项目容器的不二之选，接下来就一起学习吧 一、安装VMware Workstation Pro使用这个软件，可以直接在电脑中运行虚拟机 里边还有Xshell、Xftp工具，可以方便的操作虚拟机 链接：https://pan.baidu.com/s/1x5bhEh5pUajfA7fA6iMvNg提取码：gxju 直接安装即可 二、在VMware中安装centos7centos7镜像下载地址 http://isoredirect.centos.org/centos/7/isos/x86_64 不会的可以参考这个链接 https://blog.csdn.net/babyxue/article/details/80970526 三、配置虚拟机IP地址参考：https://blog.csdn.net/weixin_38214171/article/details/85330179 最后如下图，显示连接数据配置成功 1ping www.baidu.com 四、安装Docker在linux和windows中安装Docker很容易出错，所以我们直接使用centos7+yml的方式安装 运行下面的 yum 命令： 1yum install docker 安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动： 12service docker startchkconfig docker on 查看是否安装成功 1docker version 如果显示版本信息等，说明安装成功 五、修改国内镜像地址因为官网镜像地址速度比较慢，所以我们配置国内的镜像地址提高效率。Docker 中国官方镜像加速可通过registry.docker-cn.com访问。该镜像库只包含流行的公有镜像，私有镜像仍需要从美国镜像库中拉取。 把daemon.json修改为下边内容： 12345678vi /etc/docker/daemon.json#添加后{ &quot;registry-mirrors&quot;: [&quot;https://alzgoonw.mirror.aliyuncs.com&quot;] }#配置完成后 按ESC wq: 保存退出#重启dockerservice docker restart 六、验证是否能获取到镜像内的文件12#本地没有，会自动从环境下下载启动docker run hello-world 显示如下，说明配置成功 七、Docker常用命令可以直接输入docker，来查看所有命令 下面是一些常用的命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下:docker images#拉取docker镜像docker pull image_name#删除镜像docker rmi docker.io/tomcat:7.0.77-jre7 或者 docker rmi b39c68b7af30#查看当前有哪些容器正在运行docker ps#查看所有容器docker ps -a#启动、停止、重启容器命令：docker start container_name/container_iddocker stop container_name/container_iddocker restart container_name/container_id#后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：docker attach container_name/container_id#删除容器的命令：docker rm container_name/container_iddocker rm container_id#删除所有停止的容器：docker rm $(docker ps -a -q)#查看当前系统Docker信息docker info#从Docker hub上下载某个镜像:docker pull centos:latest#查找Docker Hub上的nginx镜像docker search nginx#将Centos这个仓库下面的所有镜像下载到本地repository。docker pull centos#项目导出成war包docker export 7691a814370e &gt; docker-demo.war#项目导入war包cat docker-demo.tar | docker import - test/docker-demo:v1.0#项目路径导入docker import http://example.com/exampleimage.tgz example/imagerepo","link":"/java-show/2019/10/10/Docker入门1--搭建Docker/"},{"title":"Spring-Cloud 初识","text":"微服务现在作为一线城市的开发工作人员而言，已经是必备技能了，我也不约而同的进入了微服的学习阶段，接下来的都是我自己在搭建微服务的记录，算是自己的笔记，方便后续翻看。 一、微服务介绍","link":"/java-show/2019/09/21/Spring-Cloud 初识/"},{"title":"Docker入门2 —— docker基础和简单启动","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 参考文档 官方文档：https://docs.docker.com/engine/reference/commandline 私人文档笔记： https://yeasy.gitbooks.io/docker_practice/ 百度百科： https://baike.baidu.com/item/Docker/13344470?fr=aladdin csdn博客： https://blog.csdn.net/qq_33256688/article/details/80319673#commentBox Docker简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 一个完整的Docker有以下几个部分组成： Docker Image镜像 DockerContainer容器 DockerRegistry仓库 1、 镜像​ Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 docker镜像启动123456789101112131415#查看镜像docker images#启动镜像docker run imagesdocker run imggeIddocker start imagesdocker start imggeId#关闭镜像docker stop imagesdocker stop imggeId#删除镜像docker rmi -f imagesdocker rmi -f imggeId 2、 容器​ 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 ​ 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 docker容器启动123456789101112131415161718#查看正在运行容器docker ps #查看所有容器docker ps -a# 启动容器# imggeId 文件id# imageName 文件名字docker start imggeIddocker start imageName#停止容器docker stop imggeIddocker stop imageName#删除容器docker rm imggeIddocker rm imageName 外部容器访问容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P（大写P） 或 -p（小写p） 参数来指定端口映射。当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口外部访问容器的启动方式 -p后边可以直接写开方端口 外部访问端口：内部映射端口 12#对外网络开方启动docker run -d -p 18080:8080 --name docker-test dockerplugindemo:latest 1234567#随机端口启动docker run -P dockerplugindemo#启动之后docker ps#就可以看到这个属性，32769就是随机生成的端口，可以通过这个端口去访问post0.0.0.0:32769-&gt;8080/tcplinux 3、 仓库镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 Docker特点 由于其基于LXC的轻量级虚拟化的特点，docker相比KVM之类最明显的特点就是启动快，资源占用小。因此对于构建隔离的标准化的运行环境，轻量级的PaaS(如dokku), 构建自动化测试和持续集成环境，以及一切可以横向扩展的应用(尤其是需要快速启停来应对峰谷的web应用)。 构建标准化的运行环境，现有的方案大多是在一个baseOS上运行一套puppet/chef，或者一个image文件，其缺点是前者需要base OS许多前提条件，后者几乎不可以修改(因为copy on write 的文件格式在运行时rootfs是read only的)。并且后者文件体积大，环境管理和版本控制本身也是一个问题。 PaaS环境是不言而喻的，其设计之初和dotcloud的案例都是将其作为PaaS产品的环境基础 因为其标准化构建方法(buildfile)和良好的REST API，自动化测试和持续集成/部署能够很好的集成进来 因为LXC轻量级的特点，其启动快，而且docker能够只加载每个container变化的部分，这样资源占用小，能够在单机环境下与KVM之类的虚拟化方案相比能够更加快速和占用更少资源 局限​ Docker并不是全能的，设计之初也不是KVM之类虚拟化手段的替代品，简单总结几点： Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用 LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的 隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库 网络管理相对简单，主要是基于namespace隔离 cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费) Docker对disk的管理比较有限 container随着用户进程的停止而销毁，container中的log等用户数据不便收集 docker仓库使用所谓仓库，其实是个镜像仓库，里面有很多别人已经打包好的镜像，可以直接使用docker pull命令将仓库中的镜像拉到本地，默认的仓库Docker的官方仓库Docker Hub Registry。 以 tutorial 为例子来实战一下吧 12345678910111213141516#获取镜像文件docker pull ddfddf/tutorial#下载完成之后 查看下载的镜像文件docker images#run命令来让镜像文件启动到容器中 #apt-get install -y ping 命令是安装一个ping命令docker run ddfddf/tutorial apt-get install -y ping#查询所有容器docker ps -a#查询正在运行的容器docker ps #启动docker run ddfddf/tutorial ping www.baidu.com 如果报错 执行下列命令（异常信息） 1docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \\&quot;ping\\&quot;: executable file not found in $PATH&quot;: unknown. 从”ping”: executable file not found in $PATH这句话中可以看出是因为ping命令没有装导致的，刚刚明明装过ping命令了，为什么没有呢？这是因为在容器中的修改并不会影响镜像，通过docker commit命令可以将这个容器提交成一个新的镜像。命令如下： 1docker commit 0299878039f0 ddfddf/ping 清空所有镜像代码 1docker rm $(docker ps -a -q) 这里的删除，只是把容器中的删除了，镜像文件还在的。 上传镜像到仓库中去首先到 https://hub.docker.com/ 中去注册一个docker账户 12#登录账号docker login -u 用户名 -p 密码 docker tag 重新命名一下， 不然会push认证不通过，代码如下： 1docker tag ddfddf/tutorial 你的用户名/tutorial 然后上传即可 1docker push 你的用户名/tutorial 搞定之后就可以使用以下命令登出了： 1docker logout 接下来去官网中就可以到自己的仓库中，查看上传的镜像文件了 docker导入和导出导入 1234# 导入war包# ubuntu.tar 包全称# test/ubuntu:v1.0 导入镜像的名字cat ubuntu.tar | docker import - test/ubuntu:v1.0 导出 1234#导入war包#镜像ID#导出文件名docker export 7691a814370e &gt; ubuntu.tar","link":"/java-show/2019/10/13/Docker入门2/"},{"title":"搭建一个自己的博客","text":"搭建博客的方法众多，我选择的搭建的平台是放在了 github pages 上边(这个功能是为大家免费提供的，不过只能放静态页面，不过作为个人博客使用已经足够了) 接下来就开始真正的搭建之旅吧。 一、安装所需插件在安装HEXO之前还需要安装另外两个软件(我用的是PC端版本) 1. git2. Node.js （自带npm）安装好之后检测是否安装成功 win + R cmd 进入 输入代码检查是否安装完成 123git --versionnode -vnpm -v 如果都显示出版本号，那么恭喜安装完成！ 二、创建路径在自己的电脑中找到一个路径，创建一个文件夹，我的如下：G:\\crc-bk 三、进入git编辑模式进入自己的文件夹里边后鼠标右键，点击 Git Bash Here 按钮 四、安装HEXO1. 下载hexo网上有很多的教程都是（第一个安装HEXO，第二个将HEXO部署到github pages上去），但是实际操作的时候发现，等好久没反应。原来这几个下载的服务器都在国外，所以没有网络下载。 如果有翻墙的朋友们可以直接翻墙下载。 12npm install hexo-cli -g hexo init 如果没有的，也不要担心，已经有人搭建了国内的镜像给我们使用。 12npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm install -g hexo-cli 2. 初始化hexo12hexo initcnpm install 3. 本地启动hexo g –这是生成页面文件,必须先生成才能启动 hexo s –启动服务器 12hexo ghexo s 启动成功之后就可以在本地访问了 本地访问路径 localhost:4000 如果访问看到该页面，那么恭喜本地启动成功！ 五、修改配置在看自己创建文件夹的路径中已经有了好多文件 编辑模式打开_confit.yml 找到url位置，配置如下 url：https://自己git id.github.io root：自己文件名字 六、上传到git12npm install hexo-deployer-git --savehexo g -d 显示 INFO Deploy done：git 表示上传成功 成功之后就可以访问自己的博客了 访问地址 https:// git id.github.io/文件名 如（ https://876745833.github.io/crc-bk/ ） 七、更新自己的博客同样的在git编辑中，输入以下命令后，在 G:\\crc-bk\\source_posts 路径下会多出.md文件 接下来按照 markdown 的标准写博客，之后上传到 git 即可 查看上传步骤 1hexo n &quot;文章标题&quot;","link":"/java-show/2019/09/15/搭建自己的博客/"},{"title":"Activiti框架——查询历史任务","text":"在Activiti框架的使用中，当我们走完一套流程之后，怎么查询我们的已经完成的任务呢？下边的方法就来介绍怎么使用。 创建测试类，引入测试用到的配置文件123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 查询流程任务这里有两种查询，根据所需 选择自己适合的方式来处理 这里我们需要注意两个方法的区别 HistoricActivityInstance（所有流程，包含流程启动、结束等） HistoricTaskInstance（人物执行相关，只有流程处理的节点） 12345678910111213141516/**查询历史活动 * act_hi_actinst 表中查 * HistoricActivityInstance（所有流程）和 HistoricTaskInstance（人物执行相关） */@Testpublic void findHisActivitiList(){ String processInstanceId = \"5001\"; List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery() .processInstanceId(processInstanceId).orderByProcessInstanceId().asc() .list(); if(list != null &amp;&amp; list.size()&gt;0){ for(HistoricActivityInstance hai : list){ System.out.println(hai.getId()+\"\"+hai.getActivityName()); } }} 123456789101112131415161718/** * 查询历史任务 * act_hi_taskinst 表中查 */@Testpublic void findHisTaskList(){ String processInstanceId = \"5001\"; List&lt;HistoricTaskInstance&gt; list = processEngine.getHistoryService() .createHistoricTaskInstanceQuery() .processInstanceId(processInstanceId).orderByProcessInstanceId().asc() .list(); if(list!=null &amp;&amp; list.size()&gt;0){ System.out.println(\"ID 流程名字 流程Key\"); for(HistoricTaskInstance hti:list){ System.out.println(hti.getId()+\" \"+hti.getName()+\" \"+hti.getTaskDefinitionKey()); } }} 查询历史流程变量查询完成的流程中，查询审核意见等一些参数（根据实例ID查询）。 12345678910111213141516/** * 查询历史流程变量 * act_hi_varinst 表中查 */@Testpublic void findHisVariablesList(){ String processInstanceId = \"5006\"; List&lt;HistoricVariableInstance&gt; list = historyService.createHistoricVariableInstanceQuery() .processInstanceId(processInstanceId) .list(); if(list != null &amp;&amp; list.size()&gt;0){ for(HistoricVariableInstance hvi:list){ System.out.println(hvi.getId()+\" \"+hvi.getVariableName()+\" \"+hvi.getValue()); } }}","link":"/java-show/2019/10/14/Activiti框架——查询历史任务/"},{"title":"Activiti————框架搭建","text":"在项目中，经常会用到流程的技术，可是自己写又非常麻烦，所以就有Activiti框架，为我们提供了一套比较完善的流程技术，在以后的项目中也会经常用到的。大家一起来学习一下吧 本项目已经全部上传github，项目地址： https://github.com/876745833/activiti-demo/tree/master 介绍 Activiti是一个轻量级的工作流和业务流程管理（BPM）平台，面向业务人员，开发人员和系统管理员。它的核心是用于Java的超快速，坚固的BPMN 2流程引擎。它是开源的，并根据Apache许可进行分发。Activiti可以在任何Java应用程序，服务器，集群或云中运行。它与Spring完美集成，非常轻巧，基于简单的概念。官方git地址 简单的说，就是一套工作申请用到框架。比如请假申请，是要经过层层的审核过程，这个时候就可以选择使用这个框架了，他本身帮我们创建的26张数据表(新版本或许更多)，提供的一些方法让我们这些程序员的开发变的更加方便、快捷。 话不多说，下边就可以正式进入框架的学习吧。 下边是搭建框架，先做好准备工作 导入jar包在maven项目中导入，在这里我们用的是 5.x版本 的 Mysql 数据库 和 5.x版本的Activiti 12345678910111213141516171819202122232425262728&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;!--activiti--&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--用到Activiti的ID策略的时候需要加--&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;com.fasterxml.uuid&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;java-uuid-generator&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;3.1.3&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt; 添加XML配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt; &lt;!-- 配置对应数据库 --&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\"&gt; &lt;property name=\"jdbcDriver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/activiti?characterEncoding=utf8\"/&gt; &lt;property name=\"jdbcUsername\" value=\"root\"/&gt; &lt;property name=\"jdbcPassword\" value=\"root\"/&gt; &lt;!-- 设置 表创建规则 databaseSchemaUpdate: 设置流程引擎启动和关闭时如何处理数据库表。 false（默认）：检查数据库表的版本和依赖库的版本， 如果版本不匹配就抛出异常。 true: 构建流程引擎时，执行检查，如果需要就执行更新。 如果表不存在，就创建。 create-drop: 构建流程引擎时创建数据库表， 关闭流程引擎时删除这些表。 --&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\"/&gt; &lt;!-- 是否使用activiti自带用户：用视图替换activiti用户 --&gt; &lt;!--&lt;property name=\"dbIdentityUsed\" value=\"false\"&gt;&lt;/property&gt;--&gt; &lt;!-- 主键生成策略 UUID --&gt; &lt;!--&lt;property name=\"idGenerator\"&gt;--&gt; &lt;!--&lt;bean class=\"org.activiti.engine.impl.persistence.StrongUuidGenerator\" /&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!-- 自定义主键生成策略 --&gt; &lt;property name=\"idGenerator\"&gt;&lt;bean class=\"TaskIdGenerator\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 使用工厂创建流程引擎对象 --&gt; &lt;bean id=\"processEngine\" class=\"org.activiti.spring.ProcessEngineFactoryBean\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\"/&gt; &lt;/bean&gt; &lt;!-- 注入bean 方便直接调用 (可选) --&gt; &lt;bean id=\"repositoryService\" factory-bean=\"processEngine\" factory-method=\"getRepositoryService\" /&gt; &lt;bean id=\"runtimeService\" factory-bean=\"processEngine\" factory-method=\"getRuntimeService\" /&gt; &lt;bean id=\"formService\" factory-bean=\"processEngine\" factory-method=\"getFormService\" /&gt; &lt;bean id=\"identityService\" factory-bean=\"processEngine\" factory-method=\"getIdentityService\" /&gt; &lt;bean id=\"taskService\" factory-bean=\"processEngine\" factory-method=\"getTaskService\" /&gt; &lt;bean id=\"historyService\" factory-bean=\"processEngine\" factory-method=\"getHistoryService\" /&gt; &lt;bean id=\"managementService\" factory-bean=\"processEngine\" factory-method=\"getManagementService\" /&gt;&lt;/beans&gt; 在配置中创建流程图如下是写的一个Demo流程图，直接在resources中创建一个leave.xml配置文件写入。 之后更改配置文件的后缀名， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:activiti=\"http://activiti.org/bpmn\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\" xmlns:tns=\"http://www.activiti.org/test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" expressionLanguage=\"http://www.w3.org/1999/XPath\" id=\"m1570697036721\" name=\"\" targetNamespace=\"http://www.activiti.org/test\" typeLanguage=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;process id=\"groupTaskDelegate\" isClosed=\"false\" isExecutable=\"true\" name=\"groupTaskDelegateProcess\" processType=\"None\"&gt; &lt;startEvent id=\"startevent1\" name=\"Start\"/&gt; &lt;userTask activiti:candidateGroups=\"部门主管\" activiti:exclusive=\"true\" id=\"usertask1\" name=\"部门主管审批\"/&gt; &lt;sequenceFlow id=\"flow1\" sourceRef=\"startevent1\" targetRef=\"usertask1\"/&gt; &lt;userTask activiti:candidateGroups=\"部门经理\" activiti:exclusive=\"true\" id=\"usertask2\" name=\"部门经理审批\"/&gt; &lt;sequenceFlow id=\"flow2\" sourceRef=\"usertask1\" targetRef=\"usertask2\"/&gt; &lt;userTask activiti:candidateGroups=\"CTO\" activiti:exclusive=\"true\" id=\"usertask3\" name=\"技术总监审批\"/&gt; &lt;sequenceFlow id=\"flow3\" sourceRef=\"usertask2\" targetRef=\"usertask3\"/&gt; &lt;endEvent id=\"endevent1\" name=\"End\"/&gt; &lt;sequenceFlow id=\"flow4\" sourceRef=\"usertask3\" targetRef=\"endevent1\"/&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram documentation=\"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0\" id=\"Diagram-_1\" name=\"New Diagram\"&gt; &lt;bpmndi:BPMNPlane bpmnElement=\"groupTaskDelegate\"&gt; &lt;bpmndi:BPMNShape bpmnElement=\"startevent1\" id=\"Shape-startevent1\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"290.0\" y=\"100.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask1\" id=\"Shape-usertask1\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"255.0\" y=\"200.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask2\" id=\"Shape-usertask2\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"255.0\" y=\"310.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"usertask3\" id=\"Shape-usertask3\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"257.0\" y=\"420.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"105.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"endevent1\" id=\"Shape-endevent1\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"292.0\" y=\"510.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow1\" id=\"BPMNEdge_flow1\" sourceElement=\"startevent1\" targetElement=\"usertask1\"&gt; &lt;omgdi:waypoint x=\"306.0\" y=\"132.0\"/&gt; &lt;omgdi:waypoint x=\"306.0\" y=\"200.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow2\" id=\"BPMNEdge_flow2\" sourceElement=\"usertask1\" targetElement=\"usertask2\"&gt; &lt;omgdi:waypoint x=\"307.5\" y=\"255.0\"/&gt; &lt;omgdi:waypoint x=\"307.5\" y=\"310.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow3\" id=\"BPMNEdge_flow3\" sourceElement=\"usertask2\" targetElement=\"usertask3\"&gt; &lt;omgdi:waypoint x=\"308.5\" y=\"365.0\"/&gt; &lt;omgdi:waypoint x=\"308.5\" y=\"420.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"flow4\" id=\"BPMNEdge_flow4\" sourceElement=\"usertask3\" targetElement=\"endevent1\"&gt; &lt;omgdi:waypoint x=\"308.0\" y=\"475.0\"/&gt; &lt;omgdi:waypoint x=\"308.0\" y=\"510.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"-1.0\" width=\"-1.0\" x=\"-1.0\" y=\"-1.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; 安装插件（Idea版本） 安装之后，再打开bpmn文件 流程图 如下：","link":"/java-show/2019/10/13/Activiti框架——搭建/"},{"title":"Activiti框架——按角色分配走流程","text":"在Activiti框架搭建好之后，我们要怎么使用这个框架呢？很简单，官方为我们提供了7个接口，分别操控框架的对应内容，下面我们来一起学习，简单的走一套完整的流程吧。 一、创建测试类，引入测试用到的配置文件下边是官方为我们提供的7大接口，他们的作用如下 123456789101112131415161718192021222324252627private final String key = \"groupTaskDelegate\";//key值private final int version = 1;//版本号//Service接口的父类，可以直接获取下边的Serviceprivate ProcessEngine processEngine;//Activiti的七大Service类private RepositoryService repositoryService;private RuntimeService runtimeService;private HistoryService historyService;private ManagementService managementService;private TaskService taskService;private IdentityService identityService;private FormService formService;@Beforepublic void init() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-activiti.xml\"); processEngine = ProcessEngines.getDefaultProcessEngine(); repositoryService = (RepositoryService) context.getBean(\"repositoryService\"); runtimeService = (RuntimeService) context.getBean(\"runtimeService\"); historyService = (HistoryService) context.getBean(\"historyService\"); managementService = (ManagementService) context.getBean(\"managementService\"); identityService = (IdentityService) context.getBean(\"identityService\"); formService = (FormService) context.getBean(\"formService\"); taskService = processEngine.getTaskService(); System.out.println(\"========== 初始化完成 ==========\");} 二、部署流程123456789101112131415161718/** * 流程定义(流程图的设计)好以后,需要部署 * 流程部署涉及到的几个动作和表 * 流程部署表 act_re_deployment * 流程定义表 act_re_procdef * 流程资源表 act_ge_bytearray */@Testpublic void complateTask() { Deployment deploy = processEngine.getRepositoryService() .createDeployment() .name(\"Activiti角色配置流程\")//部署上去名字 .addClasspathResource(\"leave.bpmn\")//bpmn文件路径 .addClasspathResource(\"leave.png\")//流程图 选择可有可无 .deploy();//部署 System.out.println(\"流程实例Id---&gt;\" + deploy.getId()); System.out.println(\"流程实例Name---&gt;\" + deploy.getName());} 在部署流程执行之后，我们在数据库中就会发现，多了很多的表，其中查看 act_re_procdef 在表 三、创建用户、角色、以及他们的对应关系1234567891011121314151617181920212223242526272829/** * 创建 角色/分组 */@Testpublic void testProcessDeploy() { IdentityService identityService = processEngine.getIdentityService(); //创建用户 act_id_user表 identityService.saveUser(new UserEntity(\"张三\")); identityService.saveUser(new UserEntity(\"李四\")); identityService.saveUser(new UserEntity(\"王五\")); identityService.saveUser(new UserEntity(\"赵六\")); identityService.saveUser(new UserEntity(\"田七\")); identityService.saveUser(new UserEntity(\"胡八\")); //创建角色 act_id_group表 identityService.saveGroup(new GroupEntity(\"部门主管\")); identityService.saveGroup(new GroupEntity(\"部门经理\")); identityService.saveGroup(new GroupEntity(\"CTO\")); System.out.println(\"角色创建完成\"); //创建角色和用户的对应关系 act_id_membership表 identityService.createMembership(\"张三\", \"部门主管\"); identityService.createMembership(\"李四\", \"部门主管\"); identityService.createMembership(\"王五\", \"部门经理\"); identityService.createMembership(\"赵六\", \"部门经理\"); identityService.createMembership(\"田七\", \"CTO\"); identityService.createMembership(\"胡八\", \"CTO\"); System.out.println(\"角色关系分配完成\");} 四、启动流程流程的启动方法有几种，我们采用最安全稳定的一种。通过实例ID来启动，保证唯一性。 12345678910111213141516171819/** * 流程的启动(流程实例的产生) new Class-&gt;Object * 涉及到的表 : * act_ru_execution 流程实例表 * act_ru_task 会产生一条待执行的任务记录 * act_hi_taskinst 也会产生一条历史任务记录(注意:endtime is null) * 注意: 以流程定义的key启动的话,默认会进入版本最新的流程 */@Testpublic void testStartProcess() { //根据key和version查出对应版本的实例Id String InstanceId = findProcessDefinition(key, version); //流程定义的key启动的话,默认会进入版本最新的流程 ProcessInstance processInstance = processEngine.getRuntimeService() .startProcessInstanceById(InstanceId,key);//启动流程 ,生成一个流程实例 System.out.println(\"流程部署的ID:\" + processInstance.getDeploymentId()); System.out.println(\"流程定义的ID:\" + processInstance.getProcessDefinitionId()); System.out.println(\"流程实例的ID:\" + processInstance.getProcessInstanceId()); System.out.println(\"流程启动完毕\");} 五、根据角色查询Task节点12345678910111213141516171819202122232425 /** * 根据角色查询某组的任务 */ @Test public void testQueryMyGroupTask() { String assignee = \"李四\"; String processinstanceId = \"30021\"; List&lt;Task&gt; taskList = processEngine.getTaskService() //跟任务处理相关的服务类 .createTaskQuery() //创建一个任务查询 .taskCandidateUser(assignee) //加入查询条件// .processInstanceId(processinstanceId)//查询某个任务 .list(); //返回形式 if (taskList != null &amp;&amp; taskList.size() &gt; 0) { for (Task task : taskList) { System.out.println(\"流程定义ID:\" + task.getProcessDefinitionId()); System.out.println(\"流程实例ID:\" + task.getProcessInstanceId()); System.out.println(\"执行对象ID:\" + task.getExecutionId()); System.out.println(\"任务ID:\" + task.getId());//任务ID:130004 System.out.println(\"任务名称:\" + task.getName()); System.out.println(\"任务的创建时间:\" + task.getCreateTime()); } } } 六、节点通过——人工流程申请过来的时候，我们要让对应的角色来完成任务，保证流程继续走下去 在分组的情况下，有人要来处理任务的时候，我们要保证只有一个人正在处理，所以我们用拾取任务来保证工作的唯一性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * 任务拾取 * 我们设置的任务处理人员暂时都只是候选人 ,并不是实际处理人,必须经过任务拾取的过程来确定谁来处理任务 * 任务拾取的过程,就是给执行任务表指定assginee字段值的过程 */ @Test public void claimTask() { String taskId = \"2504\";//刚才启动的Task的Id String userId = \"张三\";//任务拾取的用户 taskService.claim(taskId, userId); //任务拾取以后, 可以回退给组 //processEngine.getTaskService().setAssignee(taskId, null); //任务拾取以后,可以转给别人去处理(别人可以是组成员也可以不是) //processEngine.getTaskService().claim(taskId, \"xiaoxi\"); } /** * 人工节点通过方法 * 流程处理过程：完成个人任务 * 处理流程的步骤:查询个人任务 完成个人任务 * 涉及到的表：act_ru_task */ @Test public void testCompleteMyTask() { String taskId = \"22504\"; Map&lt;String, Object&gt; mapVariables = new HashMap&lt;String, Object&gt;();// mapVariables.put(\"manageId01\", \"部门主管\");// mapVariables.put(\"mes01\", \"同意，好好干，年底发红包\"); mapVariables.put(\"manageId02\", \"部门经理\"); mapVariables.put(\"mes02\", \"同意，好好干，年底发奖金\");// mapVariables.put(\"manageId03\", \"部门CTO\");// mapVariables.put(\"mes03\", \"同意，好好干，年底发分红\"); //带审核意见 processEngine.getTaskService().complete(taskId, mapVariables); System.out.println(\"审批完成\"); //不带审核意见// String taskId = \"25002\";// processEngine.getTaskService().complete(taskId);// System.out.println(\"审批任务完成\"); } 七、通过节点——自动1234567891011121314151617181920212223242526272829303132333435/** * 自动审核通过节点 */@Testpublic void testCompleteMyTaskSelf(){ String processDefinId = findProcessDefinition(key, version); ProcessInstance instance = runtimeService.startProcessInstanceById(processDefinId,key);//启动流程 ,生成一个流程实例 System.out.println(\"流程定义的ID:\" + instance.getProcessDefinitionId()); System.out.println(\"流程实例的ID:\" + instance.getProcessInstanceId()); Task task = taskService.createTaskQuery().processInstanceId(instance.getProcessInstanceId()).active().singleResult(); while (task!=null){ System.out.println(\"============\"+task.getName()+\" 流程开始 ============\"); Map&lt;String, Object&gt; mapVariables = new HashMap&lt;String, Object&gt;(); if (\"usertask1\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId01\", \"部门主管\"); mapVariables.put(\"mes01\", \"同意，好好干，年底发红包\"); } if (\"usertask2\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId02\", \"部门经理\"); mapVariables.put(\"mes02\", \"同意，好好干，年底发奖金\"); } if (\"usertask3\".equals(task.getTaskDefinitionKey())){ mapVariables.put(\"manageId03\", \"部门CTO\"); mapVariables.put(\"mes03\", \"同意，好好干，年底发分红\"); } System.out.println(\"============\"+task.getName()+\" 流程结束 ============\"); //带审核意见 processEngine.getTaskService().complete(task.getId(), mapVariables); //重新获取task task = taskService.createTaskQuery().processInstanceId(instance.getProcessInstanceId()).active().singleResult(); } System.out.println(\"审批完成\");}","link":"/java-show/2019/10/14/Activiti框架——按角色分配走流程/"},{"title":"Activiti框架常用-自定义角色方案","text":"在工作中会用到Activiti框架的时候，很多时候我们会根据自己已经有的用户角色表，来关联整个框架，这里也有一套比较完美的方案，用视图的方法，具体操作如下。 一、修改XML配置文件 我们需要修改配置文件，使框架不生成原本的用户角色表 12&lt;!-- 是否使用activiti自带用户：用视图替换activiti用户 --&gt;&lt;&lt;property name=&quot;dbIdentityUsed&quot; value=&quot;false&quot;&gt;&lt;/property&gt; 二、执行sql语句我们先创建自定义的用户、角色表，然后根据用户角色表的字段，生成与框架表对应的视图，这样就可以实现自定义的关系实现了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 创建表sqldrop table users;drop table roles;drop table userrole;CREATE TABLE act.users(id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,name varchar(30),age varchar(20),password varchar(30));CREATE TABLE act.roles(id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,roleName varchar(30));CREATE TABLE act.userrole(userId int(11),roleId int(11));-- 插入数据INSERT INTO act.users (id, name, age, password) VALUES (1, '张三', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (2, '李四', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (3, '王五', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (4, '赵六', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (5, '田七', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (6, '胡八', '25', 'admin');INSERT INTO act.users (id, name, age, password) VALUES (7, '管理员', '25', 'admin');INSERT INTO act.roles (id, roleName) VALUES (1, '部门主管');INSERT INTO act.roles (id, roleName) VALUES (2, '部门经理');INSERT INTO act.roles (id, roleName) VALUES (3, 'CTO');INSERT INTO act.roles (id, roleName) VALUES (4, '管理员');INSERT INTO act.userrole (userId, roleId) VALUES (1, 1);INSERT INTO act.userrole (userId, roleId) VALUES (2, 1);INSERT INTO act.userrole (userId, roleId) VALUES (3, 2);INSERT INTO act.userrole (userId, roleId) VALUES (4, 2);INSERT INTO act.userrole (userId, roleId) VALUES (5, 3);INSERT INTO act.userrole (userId, roleId) VALUES (6, 3);INSERT INTO act.userrole (userId, roleId) VALUES (7, 4);-- 创建的视图要保证数据类型一致，例如用户的ACT_ID_MEMBERSHIP表的两个字段都是字符型，一般系统中都是用NUMBER作为用-- 户、角色的主键类型，所以创建视图的时候要把数字类型转换为字符型。-- ACT_ID_USERCREATE OR REPLACE VIEW ACT_ID_USER_hhh(id_, rev_, first_, last_, email_, pwd_, picture_id_) as SELECT u.id,1,u.name,null,null,u.password,null FROM users u;-- ACT_ID_GROUPcreate or replace view act_id_group(id_, rev_, name_, type_) as select t.roleName , 1 as rev_,t.roleName ,'' as type_ from roles t;-- ACT_ID_MEMBERSHIPcreate or replace view act_id_membership(user_id_, group_id_) as select u.name,r.roleName fromusers u inner join userrole uron u.id=ur.userId inner join roles r on ur.roleId=r.id;-- select * from users u,roles r inner join userrole ur where u.id = ur.userId and r.id=ur.roleId;","link":"/java-show/2019/10/14/Activiti框架——自定义角色配置/"},{"title":"Activiti框架——id生成策略","text":"在使用Activiti框架的时候，我们的项目中经常会根据自己的情况，生成指定规则的id主键，那么如何来自定义主键生成策略呢？下边为大家提供了一个方法，仅供参考。 在自定义ID的方法中，有两种——UUID的方法生成和自定义方法。 修改配置文件在配置文件中加入，使得框架使用我们自定义的规则生成ID 如果需要使用UUID的，加入UUID的配置即可 如果用自定义策略，加上配置后，还需要重写IdGenerator接口 1234567 &lt;!-- 自定义主键生成策略 --&gt; &lt;property name=\"idGenerator\"&gt;&lt;bean class=\"TaskIdGenerator\"/&gt; &lt;/property&gt;&lt;!-- 主键生成策略 UUID --&gt; &lt;property name=\"idGenerator\"&gt; &lt;bean class=\"org.activiti.engine.impl.persistence.StrongUuidGenerator\"/&gt;- &lt;/property&gt; 写一个类来实现 IdGenerator 接口 通过重写IdGenerator接口来实现自定义ID的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.net.InetAddress;import java.net.UnknownHostException;import java.text.SimpleDateFormat;import java.util.Date;import org.activiti.engine.impl.cfg.IdGenerator;public class TaskIdGenerator implements IdGenerator { private static TaskIdGenerator tp=new TaskIdGenerator(); private static int number=0; private static String ip=\"\"; private TaskIdGenerator(){} public static TaskIdGenerator getInstance(){ if(tp==null){ tp=new TaskIdGenerator(); } return tp; } public String getNextId() { return getTrace(); } /** * 交易流水的生成 * data（交易流水）=1（服务器IP）+YYMMDD（日期）+111111(6为时间戳)+11111(生成数字) */ public synchronized String getTrace(){ String data=null; String IP = null; String str= null; number++; try { if(ip.equals(\"\")) { ip=InetAddress.getLocalHost().getHostAddress().split(\"[.]\")[3]; } IP=ip; } catch (UnknownHostException e) { e.printStackTrace(); } SimpleDateFormat sdf=new SimpleDateFormat(\"yyyyMMddHHmmss\"); String dateStr=sdf.format(new Date()); dateStr = dateStr.substring(2, dateStr.length()); str=\"00000\"+number; str = str.substring(str.length()-5); data=IP+dateStr+str; if(number&gt;99999){ number=0; } return data; } public static void main(String[] args) throws UnknownHostException { System.out.println(); } }","link":"/java-show/2019/10/14/Activiti框架——id生成策略/"},{"title":"Activiti框架——搭建页面管理war包","text":"在项目中，经常会用到流程的技术，可是自己写又非常麻烦，所以就有Activiti框架，为我们提供了一套比较完善的流程技术，在以后的项目中也会经常用到的。大家一起来学习一下吧 最后官方为我们提供了一个界面化管理的war包，让我们更加方便的使用框架。下面来一起看看怎么使用吧。 介绍Activiti框架官方为我们提供了官方管理页面，我们只需要去官网下载，放入tomcat等服务器下运行即可。 下边是一个5.x版本的activiti，官方好像已经找不到了。大家有需要用可以通过下方链接下载 链接：https://pan.baidu.com/s/1TI_Yx2zawFm7udg9WywoAg提取码：6pse 修改文件内的DB地址修改war包内 路径： activiti-webapp.war\\WEB-INF\\classes 的 db.properties 中的数据库地址，改为自己的。 放入tomcat启动把修改好的war包放到，tomcat的webapp路径下。 接下来进入tomcat的bin目录，win版本的，双击startup.bat ，启动成功，去页面访问即可。 访问地址： http://localhost:8080/activiti-webapp/ 看到这个页面后，恭喜启动成功了。 可以使用系统默认用户访问 1234账号 密码 角色kermit kermit admingonzo gonzo managerfozzie fozzie user 登录后看到这个页面，说明成功了","link":"/java-show/2019/10/14/Activiti框架——搭建页面管理war包/"},{"title":"sql基础知识","text":"以mysql为例子的sql语句学习 SQL的组成类型 创建表12345678910#创表sqlCREATE TABLE act.table_name( id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL, date2 datetime DEFAULT CURRENT_TIMESTAMP, var_str varchar(30), var_default varchar(30) DEFAULT 'FPX牛逼', `dec` decimal(8,2)); 创建格式：create + tableName + (创建的表字段)； int 数字类型 decimal 数字类型(可以设置精确度) timestamp 日期类型(不可为空) datatime 日期类型(可以为空) varchar 字符串类型 增加数据1234#增加数据INSERT INTO table_name (id, date, date2, `var_str`, `var-str`, `decimal`) VALUES (12, '2019-11-12 14:04:05', '2019-11-12 14:04:05', '新增 ', 'FPX牛逼', null);INSERT INTO table_name (`varchar`, `varchar-default`, `decimal`) VALUES ('新增 ', 'default', null); 格式：insert into table_name(字段，字段，字段—) values(参数，参数，参数—) 查询首先，我们来插入一些数据（输入下列sql执行） 12345678910INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (1, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '2', 'FPX牛逼', 1.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (2, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '3', 'FPX牛逼', 2.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (3, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '4', 'FPX牛逼', 3.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (4, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '5', 'FPX牛逼', 3.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (5, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '6', 'FPX牛逼', 5.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (6, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '6', 'FPX牛逼', 6.00);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (7, '2019-11-12 14:12:57', '2019-11-12 14:12:57', '6', 'FPX牛逼', null);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (8, '2019-11-12 14:52:31', '2019-11-12 14:52:31', '张三', 'FPX牛逼', null);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (9, '2019-11-12 14:52:31', '2019-11-12 14:52:31', '张四', 'FPX牛逼', null);INSERT INTO act.table_name (id, date, date2, var_str, var_default, `dec`) VALUES (10, '2019-11-12 14:52:31', '2019-11-12 14:52:31', '李四', 'FPX牛逼', null); 查表是我们使用中，使用最多的一种。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#查询全部表数据select * from table_name;#查询个别字段，并且定义临时表名select var_str,var_default from table_name;select var_str '名字',var_default '值' from table_name; #条件查询 查询id是1的数据select * from table_name where id = 1;#多条件查询 select * from table_name where id in(4,5,6) and var_str = '6';#范围查询select * from table_name where id in (1,2,3);select * from table_name where id not in (1,2,3);#模糊查询 查询var_str中以 张 开头的所有数据select * from table_name where var_str like '张%';#模糊查询 查询var_str中以 四 结尾的所有数据select * from table_name where var_str like '%四';#模糊查询 查询var_str中包含 三 的所有数据select * from table_name where var_str like '%三%';#分组查询 以var_str分组查询select var_str from table_name group by var_str;#查询排序 desc倒叙(从大到小) asc顺序(从小到大) 不写默认ascselect * from table_name order by id desc;select * from table_name order by id asc;#使用函数查询 #查询条件下个数select count(1) from table_name;select count(1) from table_name where id &gt; 5;#查询数据字段 总和select sum(`dec`) from table_name where id in(1,2,3);#查询平均值select avg(`dec`) from table_name where id in(1,2,3);#查询最大值select max(`dec`) from table_name where id in (1,2,3);#查询最小值select min(`dec`) from table_name where id in (1,2,3);#在不同条件下的去除重复结果select distinct * from table_name;select distinct var_str from table_name;select distinct var_default from table_name;select distinct `dec` from table_name; 格式：select 函数 / * from table_name 条件 改表当我们在使用过程中，发现表字段需要做修改处理，这时候我们就要来修改表。 不同数据库的修改方法可能有区别，我这里使用的是MySql数据库 12345678#修改表名字ALTER TABLE table_name CHANGE var_str name varchar(30);#修改表结构ALTER TABLE table_name MODIFY var_str int(30);#修改删除表字段ALTER TABLE table_name DROP var_str;#修改新增表字段ALTER TABLE table_name ADD newRow varchar(30) NULL; 删除一、删除单行数据1234#删除其中一条 varchar值为1的数据delete from table_name where id = '1';#删除范围多条数据 删除var_str是6的所有数据delete from table_name where var_str = '6'; 二、删除table​ 表删除有三种，下边我们来对比下三种删除的区别 drop truncate delete 删除表结构，删除所有数据 删除表中所有数据 删除条件范围的数据 1234#三种删除写法truncate table table_name;drop table table_name;delete from table_name where id = 1;","link":"/java-show/2019/11/12/sql学习入门/"},{"title":"Docker实战1 —— IDEA插件连接Docker部署","text":"Idea作为大家常用的开发软件，他的强大的插件库让我们的开发变的更加方便，接下来我们就来用docker连接的插件，让我们的docker部署变得更加容易吧。 一、开放docker和防火墙的端口参考： https://www.cnblogs.com/hsz-csy/p/9488469.html 1vi /usr/lib/systemd/system/docker.service 在ExecStart=/usr/bin/dockerd-current 后面加上 (效果如图) -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 12#修改防火墙开方端口：vi /etc/sysconfig/iptables 12#之后重启防火墙即可service iptables restart 二、下载插件 像这样，安装后重启软件 重启之后 同样进入设置中，选择Docker配置 如图： 三、IDEA的Docker插件实战参考： https://xinchen.blog.csdn.net/article/details/100051325#commentsedit 创建一个SpringBoot项目 pom.xml 的内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.bolingcavalry&lt;/groupId&gt; &lt;artifactId&gt;dockerplugindemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dockerplugindemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 把启动类 同时设置为Controller使用 1234567891011121314151617/** * 用启动类同时作为Controller，增加一个web响应接口： */@SpringBootApplication@RestControllerpublic class DockerApplication { public static void main(String[] args) { SpringApplication.run(DockerApplication.class, args); } @RequestMapping(&quot;/test&quot;) public String test(){ return &quot;1. Hello world ! &quot; + new SimpleDateFormat(&quot; [yyyy-mm-dd HH:mm:ss]&quot;).format(new Date()); }} 在项目的根目录中(pom.xml文件所在目录下)，创建名字为 *Dockerfile * 的文件，内容如下 123456789101112131415161718192021222324# Docker image for springboot application# VERSION 0.0.1# Author: bolingcavalry### 基础镜像，使用alpine操作系统，openjkd使用8u201FROM openjdk:8u201-jdk-alpine3.9#作者MAINTAINER BolingCavalry &lt;zq2599@gmail.com&gt;#系统编码ENV LANG=C.UTF-8 LC_ALL=C.UTF-8#声明一个挂载点，容器内此路径会对应宿主机的某个文件夹VOLUME /tmp#应用构建成功后的jar文件被复制到镜像内，名字也改成了app.jarADD target/dockerplugindemo-0.0.1-SNAPSHOT.jar app.jar#启动容器时的进程ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]#暴露8080端口EXPOSE 8080 创建Dockerfile配置 最后在下边选择maven 1clean package -U -DskipTests 在这件Command line 输入 12#表示每次在构建镜像之前，都会将当前工程清理掉并且重新编译构建：clean package -U -DskipTests 完成后就可以启动了 点击绿色三角，启动项目 没有报错，可以直接访问地址 （ http://192.168.19.128:18080/test ）换成自己的ip地址 访问到说明成功了，如果有修改再去运行就好了","link":"/java-show/2019/10/12/Docker实战1IDEA插件连接Docker部署/"},{"title":"Docker实战3 —— 安装Mysql","text":"参考： https://segmentfault.com/a/1190000019708313 从仓库下载123#下载自己需要的版本 V8.0.16 V5.7docker pull mysql:8.0.16docker pull mysql:5.7 启动Mysql1234#查看下载的信息docker images#开方3306端口启动 设置用户名密码123456docker run --name mysql-main -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 开方远程访问权限123456789101112131415#进入容器内docker exec -it mysql-main bash#进入mysqlmysql -u root -p#设置远程的授权 #这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址grant all privileges on *.* to root@&quot;%&quot; identified by &quot;123456&quot; with grant option; #更改用户密码ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;#刷新，一定要做，否则不生效flush privileges; #退出exit","link":"/java-show/2019/10/14/Docker实战3安装mysql/"},{"title":"SpringBoot入门01——创建springboot项目","text":"SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 特点SpringBoot所具备的特征有： （1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs； （2）内嵌Tomcat或Jetty等Servlet容器； （3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置； （4）尽可能自动配置Spring容器； （5）提供准备好的特性，如指标、健康检查和外部化配置； （6）绝对没有代码生成，不需要XML配置。 搭建SpringBoot(使用IDEA工具)1、新建项目 2、选择spring initializer(这个需要联网使用) 3、写入自己的项目名 4、选择使用技术(这里可以不做选择，手动加入) 5、创建完成 6、写一个controller，进行访问这里我们使用了注解 @RestController 的意义就相当于 @Controller + @ResponseBody @RequestMapping 访问地址 1234567@RestControllerpublic class ControllerTest { @RequestMapping(\"/hello\") public String index() { return \"Hello World\"; }} 7、启动项目进入Application项目中，运行这个main方法 8、访问启动的项目访问路径 localhost:8080/hello 显示结果如下 说明启动成功","link":"/java-show/2019/09/15/SpringBoot入门01——创建springboot项目 - 副本/"},{"title":"Docker实战2 ——  安装Nginx","text":"从仓库获取Nginx12#获取docker pull nginx 运行容器12#对外开放80端口，对内开放80端口docker run -p 80:80 --name nginx -d nginx 复制配置文件到宿主机12345#查看nginx的配置文件目录docker exec nginx ls /etc/nginx#复制docker cp -a nginx:/etc/nginx/ /srv/nginx/conf 停止并删除1234#停止docker stop nginx#删除docker rm nginx 重新运行容器1docker run -p 80:80 --restart always --name nginx -v /srv/nginx/www:/www -v /srv/nginx/conf/:/etc/nginx/ -v /srv/nginx/logs:/var/log/nginx -v /srv/nginx/wwwlogs:/wwwlogs -d nginx 已安装完成，启动Nginx如有需要就直接修改/srv/nginx/conf/conf.d目录下的配置文件，然后重启Nginx容器即可生效 1docker restart nginx","link":"/java-show/2019/10/11/Docker实战2安装linux/"},{"title":"Docker入门2 —— docker基础和简单启动","text":"如果你想要从一个基础镜像开始建立一个自定义镜像，可以选择一步一步进行构建，也可以选择写一个配置文件，然后一条命令（docker build）完成构建，显然配置文件的方式可以更好地应对需求的变更，这个配置文件就是Dockerfile。 创建dockerFile同样的，我们以一个案例来操作学习。我们以 debian-jdk8 这个来举例 首先在自己的指定目录下创建一个文件目录 ~/debian-jdk8 123456789#进入指定目录cd /user/local#创建文件夹mkdir debian-jdk8 #进入目录cd debian-jdk8 #写dockerfilevi Dockerfile 其中dokcerfile内容如下(键盘 i 进入编辑模式，按ESC + 输入 wq 保存退出) 1234567891011121314151617181920212223242526272829303132FROM debian:stretchARG DEBIAN_FRONTEND=noninteractiveARG JAVA_VERSION=8ARG JAVA_UPDATE=172ARG JAVA_BUILD=11ARG JAVA_PACKAGE=jdkARG JAVA_HASH=a58eab1ec242421181065cdc37240b08ENV LANG C.UTF-8ENV JAVA_HOME=/opt/jdkENV PATH=${PATH}:${JAVA_HOME}/binRUN set -ex \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get -y install ca-certificates wget unzip \\ &amp;&amp; wget -q --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; \\ -O /tmp/java.tar.gz \\ http://download.oracle.com/otn-pub/java/jdk/${JAVA_VERSION}u${JAVA_UPDATE}-b${JAVA_BUILD}/${JAVA_HASH}/${JAVA_PACKAGE}-${JAVA_VERSION}u${JAVA_UPDATE}-linux-x64.tar.gz \\ &amp;&amp; CHECKSUM=$(wget -q -O - https://www.oracle.com/webfolder/s/digest/${JAVA_VERSION}u${JAVA_UPDATE}checksum.html | grep -E &quot;${JAVA_PACKAGE}-${JAVA_VERSION}u${JAVA_UPDATE}-linux-x64\\.tar\\.gz&quot; | grep -Eo &apos;(sha256: )[^&lt;]+&apos; | cut -d: -f2 | xargs) \\ &amp;&amp; echo &quot;${CHECKSUM} /tmp/java.tar.gz&quot; &gt; /tmp/java.tar.gz.sha256 \\ &amp;&amp; sha256sum -c /tmp/java.tar.gz.sha256 \\ &amp;&amp; mkdir ${JAVA_HOME} \\ &amp;&amp; tar -xzf /tmp/java.tar.gz -C ${JAVA_HOME} --strip-components=1 \\ &amp;&amp; wget -q --header &quot;Cookie: oraclelicense=accept-securebackup-cookie;&quot; \\ -O /tmp/jce_policy.zip \\ http://download.oracle.com/otn-pub/java/jce/${JAVA_VERSION}/jce_policy-${JAVA_VERSION}.zip \\ &amp;&amp; unzip -jo -d ${JAVA_HOME}/jre/lib/security /tmp/jce_policy.zip \\ &amp;&amp; rm -rf ${JAVA_HOME}/jar/lib/security/README.txt \\ /var/lib/apt/lists/* \\ /tmp/* \\ /root/.wget-hsts 保存之后执行语句 1docker build -t debian-jdk8:v1.0 . 其中-t debian-jdk8:v1.0表示打包的镜像名为debian-jdk，tag为v1.0（前面说过，tag是可以任意命名的，不一定要是这种格式），注意命令的最后有一个.，这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录，然后目录下的Dockerfile就会被编译执行。 12#执行完之后 查看镜像docker images dockerFile写法规则参考： https://www.cnblogs.com/andyfengzp/p/6424150.html 参考： http://www.ityouknow.com/docker/2018/03/15/docker-dockerfile-command-introduction.html 1、FROM(指定基础镜像)123FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt;:&lt;digest&gt; 2、MAINTAINER(指定镜像创建者信息)1MAINTAINER CRC &lt;876745833@qq.com&gt; 3、RUN（运行命令）1234#shell格式RUN &lt;command&gt;#exec格式RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] 例如： RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai 1234ln -sf 是linux命令ln 它的功能是为某一个文件在另外一个位置建立一个不同的链接-s = soft 意为软链接-f = force 表示强制创建（使用前请备份之前存在文件） 4、ENV（设置环境变量）12#例如 不同环境配置的也不同 根据情况来配置使用ENV LANG en_US.UTF-8 5、WORKDIR（切换目录） WORKDIR用于在容器内设置一个工作目录： 1WORKDIR /path/to/workdir 通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录： 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 在以上示例中，pwd 最终将会在 /a/b/c 目录中执行。在使用 docker run 运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。 6、CMD（设置容器启动时执行的操作）123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]CMD [&quot;param1&quot;,&quot;param2&quot;]CMD command param1 param2 例如：CMD $CATALINA_HOME/bin/startup.sh &amp;&amp; tail -F $CATALINA_HOME/logs/catalina.out 7、EXPOSE（指定容器需要映射到宿主机器的端口）例如：EXPOSE 8080 9090 8、VOLUME（指定挂载点)例如：VOLUME $CATALINA_HOME/webapps $CATALINA_HOME/logs $CATALINA_HOME/conf 9、USER 指定当前用户 USER 用于指定运行镜像所使用的用户： 1USER daemon 使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试： 123456USER userUSER user:groupUSER uidUSER uid:gidUSER user:gidUSER uid:group 使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。","link":"/java-show/2019/10/13/Docker入门3DockerFile学习使用/"},{"title":"SpringBoot入门01——创建springboot项目","text":"SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。 特点SpringBoot所具备的特征有： （1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs； （2）内嵌Tomcat或Jetty等Servlet容器； （3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置； （4）尽可能自动配置Spring容器； （5）提供准备好的特性，如指标、健康检查和外部化配置； （6）绝对没有代码生成，不需要XML配置。 搭建SpringBoot(使用IDEA工具)1、新建项目 2、选择spring initializer(这个需要联网使用) 3、写入自己的项目名 4、选择使用技术(这里可以不做选择，手动加入) 5、创建完成 6、写一个controller，进行访问这里我们使用了注解 @RestController 的意义就相当于 @Controller + @ResponseBody @RequestMapping 访问地址 1234567@RestControllerpublic class ControllerTest { @RequestMapping(\"/hello\") public String index() { return \"Hello World\"; }} 7、启动项目进入Application项目中，运行这个main方法 8、访问启动的项目访问路径 localhost:8080/hello 显示结果如下 说明启动成功","link":"/java-show/2019/09/15/SpringBoot入门01——创建springboot项目/"}],"tags":[{"name":"Activiti工作流","slug":"Activiti工作流","link":"/java-show/tags/Activiti工作流/"},{"name":"Docker","slug":"Docker","link":"/java-show/tags/Docker/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/java-show/tags/SpringCloud/"},{"name":"分享","slug":"分享","link":"/java-show/tags/分享/"},{"name":"数据库","slug":"数据库","link":"/java-show/tags/数据库/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/java-show/tags/SpringBoot/"}],"categories":[{"name":"框架","slug":"框架","link":"/java-show/categories/框架/"},{"name":"Docker","slug":"Docker","link":"/java-show/categories/Docker/"},{"name":"SrpingCloud","slug":"框架/SrpingCloud","link":"/java-show/categories/框架/SrpingCloud/"},{"name":"Activiti工作流","slug":"框架/Activiti工作流","link":"/java-show/categories/框架/Activiti工作流/"},{"name":"博客系列","slug":"博客系列","link":"/java-show/categories/博客系列/"},{"name":"Linux","slug":"Docker/Linux","link":"/java-show/categories/Docker/Linux/"},{"name":"IDEA","slug":"Docker/IDEA","link":"/java-show/categories/Docker/IDEA/"},{"name":"Centos7","slug":"Docker/Linux/Centos7","link":"/java-show/categories/Docker/Linux/Centos7/"},{"name":"数据库","slug":"数据库","link":"/java-show/categories/数据库/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/java-show/categories/SpringBoot/"}]}